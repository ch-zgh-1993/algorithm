<!--
* @Author: Zhang Guohua
* @Date:   2020-04-21 16:36:29
* @Last Modified by:   zgh
* @Last Modified time: 2020-04-22 15:51:12
* @Description: create by zgh
* @GitHub: Savour Humor
-->
<!DOCTYPE html>
<html>
<head>
	<title>动态规划</title>
</head>
<body>


<script type="text/javascript">
	// 定义： 动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（分治）的方式去解决。
	// 

	// 理解： 与分治法类似，分解问题，按顺序求出问题的最优解，每一个字问题的最优解，组合成最终的最优解。
	//  	动态规划解决问题过程中，出现重叠字问题，为减少重复计算，对每个子问题只解一次，将不同阶段的不同状态保存在一个二维数组/矩阵中。

	// 过程： 
	// 1. 状态： 看看题目问题能不能作为状态，什么状态好转移，就用什么状态，方便状态转移方程构建。 
	// 2. 状态转移方程： 分类讨论，状态点，需要分类进行讨论。就是把当前问题分解成多个小问题，小问题的解，最优解，构成了当前问题的解。
	// 3. 初始化： 从问题分析定义初始化； 从状态转移方程的下标思考初始化状态，数组不能越界，或者是否可以通过给状态数组，矩阵多加一行/一列。从而避免复杂的初始化讨论。
	// 4. 输出： 根据问题决定。
	// 5. 考虑状态数组(矩阵) 是否可以压缩： 考虑状态是否不再使用，压缩状态优化。


	// 技巧:
	// 1. 通过题目，要求获取状态，考虑状态转移方程，如果不容易得到，就修改状态定义。
	// 2. 状态转移方程： 其实就是分类讨论，对状态空间进行分类。
	// 3. 初始化很重要，要依据定义，进行思考。这里要注意越界，可以增加一行，一列作为哨兵。
	// 4. 状态压缩，在数据量非常大时，空间不够时进行考虑。



	// 注意：
	// 1. 这个不一定是通过函数去实现的。通过循环，什么形式都可以。


	// 例子：
	// 		1. 数字三角形问题：




	// 数字三角形问题： 三角形行数大于 1 ，小于100；数字为 0 - 99；
	// 输入格式： 行数（n） 每一行的数字。 求最佳路径长度，数字之和。
	// 存储结构： 二维数组 triangle[i][j] 表示 i, j 的值。 那么Max[i][j] 表示从 i，j 到底边的和最大，求 Max[1][1]
	// 状态，就是每个点的最优解，向上走时，选择不同的路，进行处理。保证不走已经选过的路，需要一个方向记录。
	// 状态转移： 从当前的最优解，转换为每个点的最优解。
	// 输出：

	(() => {
		// 创造三角形
		function createTr() {
			let r = Math.floor(Math.random() * 99 + 2);
			let arr = new Array(r + 1)
			for (let i = 1; i < arr.length; i++) {
				arr[i] = []
				for(let j = 1; j <= i ; j++) {
					arr[i][j] = Math.floor(Math.random() * 99)
				}
			}
			return arr
		}
		for (let i = 0; i < 1; i++) {
			let index = createTr()
			console.log(index)
			getTrSum(index.length - 1, JSON.parse(JSON.stringify(index)))
		}
		
		function getTrSum(r, arr) {
			for (let i = r - 1; i >= 1; i--) {
				for (let j = 1; j <= i; j++) {
					arr[i][j] += Math.max(arr[i+1][j], arr[i+1][j+1])
				}
			}
			return arr[1][1]
		}

	})()


</script>
</body>
</html>